## Conectividade
Nesse paper será abordado os seguintes tópicos:
- Definição básica de rede
	- IP
	- TCP/UDP
	- Serviços 
	- ICMP
- Comunicação de Rede.
- DNS

### Definição Básica de Rede. 
Bom, estamos todos conectados à Internet. Na Internet todo mundo tem que ter um endereço para que possa acessar e ser acessado outros Hosts na Internet.

#### O que é um IP?
IP é um protocolo que está para Internet Protocol, ele basicamente é um protocolo de endereçamento e opera na camada de rede. Vamos focar apenas no IPv4, possui 32 bits:
![IPv4](https://core0.staticworld.net/images/article/2015/11/ipv4-100629207-orig.png)

O que nós chamamos de octeto é a composição de 8 bits por bloco sendo no total 4 blocos resultando em 32 bits. Conforme a imagem acima pode-se notar que é convertido de decimal para binário. Não entraremos nos detalhes sobre conversão e máscaras de rede etc, o foco não é esse. O que importa é que todos temos um endereço IPv4 público. 

Para você identificar o seu endereço na Internet você pode abrir um site qualquer que informe seu endereço IPv4 mas como estamos lidando com um paper sobre shellscript vamos fazer isso usando o comando curl: 

```
curl meuip.com | egrep "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]"
```
O comando acima utiliza o **curl** e o **egrep** com um pouco de expressão regular. O **curl** irá fazer uma requição web para **meuip.com** e atráves do pipe irá encaminhar para a entrada do comando **egrep** que irá aplicar a expressão regular e trazer todas as ocorrencias do que seria um endereço IPv4. 

Esse é o seu endereço IPv4 na Internet. 
#### Protocolos de Transporte. 
Mais além disso nós temos dois protocolos principais de transporte, o **TCP** e o **UDP**, eles operam de forma diferente e são os responsáveis por ir até o nosso destino. 

- TCP: Opera com estabelecimento de conexão atráces do 3way handshake, trata perda de pacotes e etc.
- UDP: Simplesmente envia, sem estabelecer a conexão antes e tão pouco se importa se o pacote chegou ao destino. 

#### Serviços
Então a partir disso tudo, nós seres humanos acessamos serviços na Internet, por exemplo, um website. Websites geralmente operam em duas portas **80** e **443**, sendo a primeira que não implementa criptografia e a segunda que implementa criptografia usando SSL/TLS. 

Então com isso em mente nós podemos simplesmente nos conectar a esses serviços usando o endereço IP e a Porta. 

Vamos realizar um teste utilizando o netcat. O Netcat é o canivete suiço dos hackers pois permite conexão em portas usando tanto TCP como UDP e outras coisas interessantes. 

A sintaxe do netcat é bem simples:
```
nc <IP> <port> 
```

Então vamos nos conectar ao servidor **meuip.com**:

```
$ echo 'GET / HTTP/1.1/r/n' | nc meuip.com 80
HTTP/1.1 400 Bad Request
Date: Sat, 17 Nov 2018 21:57:20 GMT
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.6.38
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
</body></html>

```
Então é possível lidar com esses serviços diretamente atráves da linha de comando. Existem vários outros serviços, cada porta é um serviço de rede, segue abaixo uma tabela: 
![network ports](https://patentimages.storage.googleapis.com/WO2002061510A2/imgf000036_0001.png)

Você também poderia consultar o arquivo **/etc/services** das duas seguintes formas:
```
$ grep '80/tcp' /etc/services 
http		80/tcp		www		# WorldWideWeb HTTP
socks		1080/tcp			# socks proxy server
http-alt	8080/tcp	webcache	# WWW caching service
amanda		10080/tcp			# amanda backup services
canna		5680/tcp			# cannaserver
``` 
Observe que ele exibe a porta 80/tcp como sendo um serviço HTTP. 

A outra forma seria atráves do **getent** que realiza a busca nessa base: 
```
$ getent services 80
http                  80/tcp www

```

Com isso nós sabemos que a porta 80/TCP geralmente é para serviços de HTTP, isso é um padrão porem não mandatório, o responsável pelo servidor poderia simplesmente colocar qualquer outro serviço na porta 80/tcp porém como falei, se ele colocasse o website na porta 8888, por padrão todo mundo iria tentar acessar a 80/tcp, logo é mais fácil colocar o serviço na porta padrão do que colocar numa outra porta.

#### ICMP
O ICMP é o tal do ping, é um protocolo que opera na camada 3, é um subprotocolo do protocolo IP porém com ele é possível realizar pings em portas, o que nós podemos chamar de protocolo de camada 2.5(dois e meio?, acho que fica bom)

Esse protocolo faz nada mais nada menos que verificar se um host está na rede, vocẽ dispara o ping e se o servidor responder significa que ele está ONLINE, caso ele não responda ele pode estar offline ou ter algum firewall bloqueando o protocolo ICMP. 

Observe:
``` 
$ ping -c 5 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=1.45 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=1.10 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=1.69 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=1.09 ms
64 bytes from 192.168.1.2: icmp_seq=5 ttl=64 time=1.21 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4005ms
rtt min/avg/max/mdev = 1.093/1.313/1.696/0.231 ms
```

Foi disparado 5 pacotes para o ip **192.168.1.2** e ele respondeu todos os 5, significa que o host está ativo.

Agora outros programas que utilizam o icmp são:
- mtr
- traceroute/tracepath

Os dois programas tem a ideia de medir a rota até um determinado destino, então eles mapeiam todos os hop's até determinado destino, observe abaixo um exemplo de uso do comando mtr: 
```
$ mtr -n meuip.com -c 10 -r 
Start: 2018-11-17T20:06:43-0200
HOST: remember                    Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.1.2                0.0%    10   43.1   8.8   1.1  43.1  14.3
   [ REMOVIDO ]
 21.|-- 54.233.138.36              0.0%    10  360.1 214.3  74.9 419.5 113.6

```

Então nosso pacote passa por aproximadamente 20 hop's antes de alcançar nosso destino. 

Teste o comando traceroute e veja como ele funciona. 

### Comunicação de Rede.
Nesse tópico iremos abordar os seguintes programas:
- Netcat
- Telnet
- Wget
- Curl

#### Netcat
Bom, conforme citado no tópico anterior, o **netcat** é uma ferramenta muito útil pois permite que nós seres humanos conectarmos em hosts pela Internet e até ser conectados.

O netcat opera com TCP e UDP, então dá para empregar ele em vários cenários interessantes. 

Vale ressaltar que existem várias variantes do netcat, Ncat, nc etc. Porém aqui iremos trabalhar com a mantida pelos pacotes do Ubuntu. 
```shell
$ apt show netcat
Package: netcat
Version: 1.10-41.1
Priority: optional
Section: universe/net
Origin: Ubuntu
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Ruben Molina <rmolina@udea.edu.co>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: 13,3 kB
Depends: netcat-traditional (>= 1.10-39)
Download-Size: 3.436 B
APT-Sources: http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages
Description: TCP/IP swiss army knife -- transitional package
 This is a "dummy" package that depends on lenny's default version of
 netcat, to ease upgrades. It may be safely removed.
```


A sintaxe dele é bem simples:
```shell
nc options host IP address port 
```


Mas como assim? Bom é simples, com o netcat e sabendo o IP e Porta que vocẽ queira conectar, você pode interagir diretamente com o serviço. 


Você vai entender na prática: 

##### Requisição Web
Como já sabemos, o protocolo HTTP opera na porta 80, então vamos nos conectar no meu blog por exemplo: 
```
nc diesec.sytes.net 80 
```
Uma vez conectado, você pode notar que nada aconteceu, então digite o seguinte:
```
GET / HTTP/1.1
```

E o servidor irá responder com o seguinte conteúdo:
```html
HTTP/1.1 400 Bad Request
Date: Sat, 01 Dec 2018 17:33:55 GMT
Server: Apache
Vary: accept-language,accept-charset
X-Frame-Options: SAMEORIGIN
Accept-Ranges: bytes
Connection: close
Content-Type: text/html; charset=utf-8
Content-Language: en
Expires: Sat, 01 Dec 2018 17:33:55 GMT

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Bad request!</title>
<link rev="made" href="mailto:4non_47@protonmail.ch" />
<style type="text/css"><!--/*--><![CDATA[/*><!--*/ 
    body { color: #000000; background-color: #FFFFFF; }
    a:link { color: #0000CC; }
    p, address {margin-left: 3em;}
    span {font-size: smaller;}
/*]]>*/--></style>
</head>

<body>
<h1>Bad request!</h1>
<p>


    Your browser (or proxy) sent a request that
    this server could not understand.

</p>
<p>
If you think this is a server error, please contact
the <a href="mailto:4non_47@protonmail.ch">webmaster</a>.

</p>

<h2>Error 400</h2>
<address>
  <a href="/">diesec.sytes.net</a><br />
  <span>Apache</span>
</address>
</body>
</html>

```

Deu erro 400 pois o servidor não entendeu a requisição. Mas nenhum problema até agora, já conseguimos interagir com o serviço HTTP do servidor remoto. 

Agora outro truque é ligar o verbose para que ele informe caso consiga conectar, para fazer isso basta digitar: 

```
nc -evv diesec.sytes.net 80
```
A opção **e** permite que o echo interprete os caracteres de escape e o **v** aumenta o verbose. 

E o comando retorna na primeira linha o seguinte:
```
$ nc -evv diesec.sytes.net 80
Connection to diesec.sytes.net 80 port [tcp/http] succeeded!
```

Ele informa que conseguiu conectar no destino, ótimo.

A falha na requisição está no fato de que existem alguns outros elementos que precisam ser encaminhados na requisição. Para a gente ver como uma requisição é feita com um browser comum, sugiro o seguinte teste: Vamos abrir uma porta no nosso localhost e então fazer o nosso browser fazer uma requisição. 

Primeiro, abra um terminal e digite:
```
nc -tlnvp 4444
```
Agora abra o seu browser e digite na URL:
```
localhost:4444
```
E o resultado da requisição é a seguinte:
```
$ nc -tlnvp 4444
Listening on [0.0.0.0] (family 0, port 4444)
Connection from 127.0.0.1 35622 received!
GET / HTTP/1.1
Host: localhost:4444
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:63.0) Gecko/20100101 Firefox/63.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Upgrade-Insecure-Requests: 1
``` 


Então toda vez que um browser faz uma requisição web ele encaminha todas essas informações, agora fica mais fácil a gente forjar uma requisição usando o netcat, vamos tentar novamente: 

```
echo -e  'GET / HTTP/1.1\r\nHost: diesec.sytes.net\r\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:63.0) Gecko/20100101 Firefox/63.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\n\r\n' | nc -tvv diesec.sytes.net 80
```
Aqui foi passado todos os parãmetros para uma requisição válida e ela obtêm sucesso, exibindo toda a index da página. 

Mas nem todos os parâmetros são necessários, apenas definindo o GET e o HOST é possível acessar a página, segue exemplo:
```
echo -e 'GET / HTTP/1.1\r\nHost: diesec.sytes.net\r\n\r\n' | nc diesec.sytes.net 80
```


##### Chat
O Netcat pode ser utilizado para criar um chat, para isso você irá precisar de dois terminais, no primeiro terminal digite o seguinte: 
Primeiro terminal atuará como servidor: 
```
nc -tlnp 4444
```

No segundo terminal que nós iremos chamar de Cliente, execute o seguinte: 

```
nc localhost 4444
```

Então em qualquer um dos terminais se você digitar qualquer coisa e der enter irá aparecer do outro lado! 

Caso você não tenha entendido, quando se abre uma porta usando o netcat, você abre uma porta no seu sistema operacional para conexões de fora, no caso nós abrimos uma porta em todas as interfaces de rede, incluindo a lo(localhost), assim se você se conectar no localhost na porta que você abriu, você vai dentro da aplicação do netcat, simples assim. 

Digite o comando abaixo para verificar as portas abertas ainda com o terminal do servidor do nosso chat aberto: 

```
$ netstat -tlpn | grep 4444
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      16950/nc           

```

Como você pode ver, a porta 4444 está aberta para todas as interfaces, simbolizado pelo **0.0.0.0**. e um pouco mais além é possível ver de quem é o processo, ali informa o PID e o nome, no caso 16950 e o programa é o nc. 

Um outro comando interessante é o **lsof** que vocẽ pode exibir todos os processos com relação à porta 4444, observe:

```
$ lsof -i :4444
COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
nc      16950 operador    3u  IPv4 269421      0t0  TCP *:4444 (LISTEN)
nc      16950 operador    4u  IPv4 269422      0t0  TCP localhost:4444->localhost:35842 (ESTABLISHED)
nc      16951 operador    3u  IPv4 269428      0t0  TCP localhost:35842->localhost:4444 (ESTABLISHED)

```

Na saída do comando acima ele me informa que temos 3 processos, um em LISTEN e dois indicando conexão estabelecida. Super COOLL HUN?


##### Abrindo Conexão
Bom, eu falei um pouco sobre abrir conexão no tópico anterior, mas vamos reforçar. 

O netcat pode ser utilizado para receber conexões, a sintaxe é a mesma, como já expliquei o básico no tópico anterior, vou estar ilustrando alguams formas de abrir uma conexão.

Abrindo conexão em todas as interfaces
```
nc -tlnp 4444
``` 
O comando anterior vai abrir a porta 4444 para conexões TCP em todas as interfaces.

Abrindo conexão em interface especifica: 

```
nc -s 192.168.1.113 -tlp 4444

```

Onde **s** determina o endereço IP da interface que você ira dar bind e **tlp** determina um socket tcp, em listen e porta, respectivamente.


##### Scan de Porta
O Netcat pode ser empregado pra realizar portscan. PortScan é uma técnica utilizada para scanear portas e identificar as portas abertas em um servidor remoto ou no próprio servidor(levando em consideração que no próprio servidor existem meios melhores para se determinar isso, tipo pelo netstat, mas em todos os casos, porquẽ não)

Então para fazer isso é simples: 

```shellscript
$ nc -z 192.168.0.1 80-90
Connection to 192.168.0.1 80 port [tcp/http] succeeded!
```
A opção **z** indica que é para scanear por daemons sem encaminhar nenhum dado, apenas conectando. 

##### Transmissão de Arquivos/Data Exfiltration
É interessante utilizar o netcat para exfiltrar arquivos, exfiltração é muito utilizado para retirar os dados de um servidor e passar para outro local. Existem várias formas de se realizar isso, seja por conexão direta ou reversa, abaixo segue algumas formas de conexão direta: 

```
# Quem envia 
 dd if=/dev/hdb5 | gzip -9 | nc -l 3333 
 
# Quem Recebe
nc 192.168.0.1 3333 | pv -b > myhdb5partition.img.gz
```

```
# Quem Recebe
 tar -czf - /etc/ | nc -l 3333   
# Quem Envia
 nc 192.168.0.1 3333 | pv -b > mybackup.tar.gz
```

Dependendo do sentido que você estiver fazendo, seja com bind ou reverse shell, o lado que recebe os arquivos precisa encaminhar isso para um arquivo, então  você precisaria redirecionar os dados assim: 

##### BannerGrab
Banner Grab é uma técnica de enumeração/reconhecimento que você detecta qual o serviço que está operando em determinada porta, visando obter a versão do serviço para começar a levantar dados de ataque daquele vetor.

Para fazer isso basta conectar com o netcat na porta especificada e você vai pegar o banner da aplicação, exemplo:

```
# Exemplo A 
$ nc 192.168.1.25 22
SSH-2.0-OpenSSH_7.5p1 Ubuntu-10
# Exemplo B 
$ nc AlgumHost.com  22
SSH-2.0-OpenSSH_7.2
``` 

No exemplo anterior nós conectamos na porta 22 para realizar o banner grabing. Lembre-se de que o banner pode ser adulterado pelo sysadmin responsável. 


##### BindShell
Uma bindshell é quando você se conecta diretamente no alvo. Um exemplo prático é quando você obtem uma webshell por esemplo e abre uma porta nesse servidor e então se conecta nessa porta para executar comandos arbitrários. 

Para realizar tal tarefa, você simplesmente precisa abrir uma porta e direcionar o que chegar nessa porta para o bash por exemplo. 

```
nc -tlnp 4444 -e /bin/bash 
```
A partir disso você se conecta no alvo na porta aberta e poderá executar comandos. 

Existem diversos problemas no emprego do netcat nessa técnica, um deles é que ele perdeu a feature **e** para execução de um programa. Iremos mais além nesse curso falar sobre isso e como contornar a situação. 

##### ReverseShell
Uma reverseShell entra em ação quando existe algum firewall bloqueando o acesos no seu alvo, mesmo vocẽ abrindo uma porta pra realizar a conexão, você não consegue estabelecer pois o firewall vai estar bloqueando a porta que você utilizou. Um truque então é usar uma revershell onde você faz o alvo se conectar ao auditor, no caso à vocẽ. 

Nesse caso, você abre uma porta na sua máquina, e no servidor alvo você conecta na sua máquina na porta aberta. Muitos firewalls deixam isso passar pois só bloqueiam tráfego inbound, não outbound. 


##### Piping e Redirecionamentos
Você já deve ter notado anteriormente a utilização de Pipe **|** para redirecionar saídas para outros arquivos ou até mesmo a entrada. 

Você pode estar utilizando pipes com o netcat da seguinte forma: 
```
nc -vv -z localhost 1-100 > output.txt 2>&1
```

Alguns outros exemplos já foram exibidos em tópicos anteriores, dẽ uma olhada novamente!

#### Telnet
Telnet é um serviço de rede que opera apenas com TCP e por padrão na porta 23, muito utilizado para administração de switchs e roteadores. 

Existe um utilitário no próprio linux chamado de **telnet**, e vocẽ pode estar utilizando para realizar as conexões de telnet. O Netcat pode ser empregado como cliente de telnet. 

#### Wget
Wget é uma ferramenta muito interessante de acesso á paginas web, nós iremos utilizar ela mais além para clonagem de websites.

Atráves do wget você pode fazer requisições web e até mesmo forjar o user-agent, pode ser empregado também para download de qualquer coisa que esteja num webserver além de páginas web claro, por exemplo arquivos. 

A sintaxe é bem simples, segue: 

```
   wget [option]... [URL]...

``` 

Para realizarmos o download da index do meu blog ou qualquer outro site de sua preferência, simplesmente execute:

```
$ wget diesec.sytes.net 
--2018-12-01 17:59:52--  http://diesec.sytes.net/
Resolving diesec.sytes.net (diesec.sytes.net)... 13.58.236.213
Connecting to diesec.sytes.net (diesec.sytes.net)|13.58.236.213|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘index.html’

index.html                                    [  <=>                                                                                 ]  22,00K   103KB/s    in 0,2s    

2018-12-01 17:59:54 (103 KB/s) - ‘index.html’ saved [22533]


```
Vai ser gerado um arquivo **index.html** no mesmo diretório onde o comando foi executado, que no caso é a página requisitada. 

Para direcionar o arquivo requisitado para outro diretório e com outro nome, pode ser utilizado a flag **O**. segue exemplo: 
```
$ wget diesec.sytes.net -O /tmp/index
--2018-12-01 18:01:42--  http://diesec.sytes.net/
Resolving diesec.sytes.net (diesec.sytes.net)... 13.58.236.213
Connecting to diesec.sytes.net (diesec.sytes.net)|13.58.236.213|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘/tmp/index’

/tmp/index                                    [  <=>                                                                                 ]  22,00K   106KB/s    in 0,2s    

2018-12-01 18:01:43 (106 KB/s) - ‘/tmp/index’ saved [22533]
```

#### Curl



### DNS
Nesse tópico iremos abordar os seguintes tópicos:
- O que é DNS 
- Dig
- Host

#### Fontes
https://www.hackingtutorials.org/networking/hacking-with-netcat-part-1-the-basics/
https://www.hackingtutorials.org/networking/hacking-with-netcat-part-3-advanced-techniques/
https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-netcat-swiss-army-knife-hacking-tools-0148657/
https://osric.com/chris/accidental-developer/2018/01/using-nc-netcat-to-make-an-http-request/
https://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/
http://notes.rioastamal.net/2014/02/faking-services-using-netcat-for-nagios-testing.html
